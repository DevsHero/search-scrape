--INPUT--

{
  "url": "https://doc.rust-lang.org/book/ch17-00-async-await.html",
  "max_chars": 2500,
  "output_format": "text"
}


--OUTPUT--

Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams - The Rust Programming Language
URL: https://doc.rust-lang.org/book/ch17-00-async-await.html
Canonical: -
Word Count: 1615 (9m)
Language: en
Site: -
Author: -
Published: -

Description: 
OG Image: -

Headings:
- H1 The Rust Programming Language
- H1 Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams
- H2 Keyboard shortcuts
- H2 Parallelism and Concurrency

Links: 4  Images: 3

Preview:
[Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams](#fundamentals-of-asynchronous-programming-async-await-futures-and-streams) ========== Many operations we ask the computer to do can take a while to finish. It would be nice if we could do something else while we’re waiting for those long-running processes to complete. Modern computers offer two techniques for working on more than one operation at a time: parallelism and concurrency. Our programs’ logic, however, is written in a mostly linear fashion. We’d like to be able to specify the operations a program should perform and points at which a function could pause and some other part of the program could run instead, without needing to specify up front exactly the order and manner in which each bit of code should run. *Asynchronous programming* is an abstraction that lets us express our code in terms of potential pausing points and eventual results that takes care of the details of coordination for us. This chapter builds on Chapter 16’s use of threads for parallelism and concurrency by introducing an alternative approach to writing code: Rust’s futures, streams, and the `async` and `await` syntax that let us express how operations could be asynchronous, and the third-party crates that implement asynchronous runtimes: code that manages and coordinates the execution of asynchronous operations. Let’s consider an example. Say you’re exporting a video you’ve created of a family celebration, an operation that could take anywhere from minutes to hours. The video export will use as much CPU and GPU power as it can. If you had only one CPU core and your operating system didn’t pause that export until it completed—that is, if it executed the export *synchronously*—you couldn’t do anything else on your computer while that task was running. That would be a pretty frustrating experience. Fortunately, your computer’s operating system can, and does, invisibly interrupt the export often enough to let you get other work done simultaneously. Now say you’re downloading a video shared by someone else, which can also take a while but does not take up as much CPU time. In this case, the CPU has to wait for data to arrive from the network. While you can start reading the data once it starts to arrive, it might take some time for all of it to show up. Even once the data is all present, if the video is quite large, it could take at least a second or two to load it all. That might not sound like much, bu

[Content truncated: 2500/9579 chars shown. Increase max_chars parameter to see more]

Sources:
[1]: https://doc.rust-lang.org/book/print.html
[2]: https://github.com/rust-lang/book
[3]: https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html
[4]: https://doc.rust-lang.org/book/ch17-01-futures-and-syntax.html
